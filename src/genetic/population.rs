use petgraph::graph::UnGraph;

use super::{heuristics::Heuristic, Chromosome};

/// Represents a population of chromosomes for evolutionary algorithms.
///
/// The population is responsible for maintaining a collection of chromosomes,
/// managing their initialization through heuristics, and calculating aggregate
/// metrics such as average fitness.
///
/// # Fields
/// - `chromosomes: Vec<Chromosome>`: A vector containing the chromosomes in the population.
/// - `size: usize`: The maximum size of the population.
#[derive(Clone)]
pub struct Population {
    chromosomes: Vec<Chromosome>,
    size: usize,
}

impl Population {
    /// Creates a new population of chromosomes using the provided heuristics and graph.
    ///
    /// This function generates chromosomes by applying the heuristics in sequence. If the
    /// population size exceeds the number of heuristics, the last heuristic is used to
    /// generate the remaining chromosomes.
    ///
    /// # Parameters
    /// - `size: usize`: The number of chromosomes to generate for the population.
    /// - `heuristics: Vec<Heuristic>`:
    ///   A vector of heuristic functions used to generate chromosomes.
    ///   Each heuristic is a function of the form `fn(&UnGraph<u32, ()>) -> Chromosome`.
    /// - `graph: &UnGraph<u32, ()>`:
    ///   An undirected graph that represents the problem structure.
    ///
    /// # Panics
    /// - If the `heuristics` vector is empty.
    ///   - Panic message: `"At least one heuristic must be provided."`
    ///
    /// # Returns
    /// - A new instance of `Population` with chromosomes generated by the heuristics.
    ///
    /// # Notes
    /// - Chromosomes are adjusted using their `fix` method to ensure they satisfy
    ///   problem-specific constraints.
    #[inline]
    #[must_use]
    pub fn new(size: usize, heuristics: &[Heuristic], graph: &UnGraph<u32, ()>) -> Self {
        assert!(
            !heuristics.is_empty(),
            "At least one heuristic must be provided."
        );
        let mut chromosomes = Vec::with_capacity(size);

        for heuristic in heuristics {
            if chromosomes.len() < size {
                let chromosome = heuristic(graph);
                chromosomes.push(chromosome);
            }
        }

        let last_heuristic = *heuristics.last().unwrap();
        while chromosomes.len() < size {
            let mut chromosome = last_heuristic(graph);
            chromosome.fix(graph); // Adjust the chromosome if needed.
            chromosomes.push(chromosome);
        }

        Self { chromosomes, size }
    }

    /// Returns a reference to the chromosomes in the population.
    ///
    /// # Returns
    /// - A slice of `Chromosome` representing the chromosomes in the population.
    #[inline]
    #[must_use]
    pub fn chromosomes(&self) -> &[Chromosome] {
        &self.chromosomes
    }

    /// Returns the size of the population.
    ///
    /// # Returns
    /// - A `usize` value representing the number of chromosomes in the population.
    #[inline]
    #[must_use]
    pub fn size(&self) -> usize {
        self.size
    }
}
